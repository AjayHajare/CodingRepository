Given an adjacency list of a graph adj  of V no. of vertices having 0 based index. Check whether the graph is bipartite or not.
Bipartite graph is the graph which can be colored using exactly 2 colors.

Example 1:

Input: 
3 2
0 1
1 2
Output: 1
Explanation: The given graph can be colored 
in two colors so, it is a bipartite graph.

Example 2:

Input:
4 4
0 2
0 3
2 3
3 1
Output: 0
Explanation: The given graph cannot be colored 
in two colors such that color of adjacent 
vertices differs. 


Your Task:
You don't need to read or print anything. Your task is to complete the function isBipartite() which takes V denoting no. of vertices and adj denoting adjacency list 
of graph and returns a boolean value true if graph is bipartite otherwise returns false.
 

Expected Time Complexity: O(V)
Expected Space Complexity: O(V)

Constraints:
1 ≤ V, E ≤ 10^5

********************************************************************************************************************************************************************* 
 
//This solution is based on BFS :------------------


class Solution
{
    public boolean isBipartite(int V, ArrayList<ArrayList<Integer>>adj)
    {
        int visited[] = new int[V];                                              //visited array is uesd to denote color of node.
        Arrays.fill(visited, -1);                                                //initialize visited[] array with '-1' which indicates 'no color'
        
        Queue<Integer> q = new LinkedList<Integer>();
        
        for(int i=0; i<V; i++){                                                 //This for loop ensures that method is called of each component of graph
            if(visited[i] == -1){
                if(checkBipartite(i, adj, q, visited) == false)                 //If any of component is not bipartite, then whole graph is not barpratite
                    return false;
            }
        }
        
        return true;
    }
    
    public static boolean checkBipartite(int v, ArrayList<ArrayList<Integer>>adj, Queue<Integer> q, int visited[]){
        q.add(v);
        visited[v] = 0;                                                         //Assign a color to source node.
        while(!q.isEmpty()){
            int node = q.poll();
            for(int x:adj.get(node)){                                           //For all adjacent nodes, check whether color is assign to it or not
                if(visited[x] == -1){                                           //If color is not assigned, then assign a color and add it to queue to visit next
                    visited[x] = 1-visited[node];
                    q.add(x);
                }
                else if(visited[x] == visited[node]){                           //If color is already assigned and color is same as previous node, it means both neighouring node has same color.
                    return false;                                               //So the graph is not bipartite.
                }
            }
        }
        return true;                                                            //During while loop, if none of node has same color as adjecant node, then graph is bipartite
    }
}
