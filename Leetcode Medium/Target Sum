You are given an integer array nums and an integer target. You want to build an expression out of nums by adding one of the symbols '+' and '-' before each integer 
in nums and then concatenate all the integers. For example, if nums = [2, 1], you can add a '+' before 2 and a '-' before 1 and concatenate them to build the 
expression "+2-1". Return the number of different expressions that you can build, which evaluates to target.

Example 1:

Input: nums = [1,1,1,1,1], target = 3
Output: 5
Explanation: There are 5 ways to assign symbols to make the sum of nums be target 3.
-1 + 1 + 1 + 1 + 1 = 3
+1 - 1 + 1 + 1 + 1 = 3
+1 + 1 - 1 + 1 + 1 = 3
+1 + 1 + 1 - 1 + 1 = 3
+1 + 1 + 1 + 1 - 1 = 3

Example 2:

Input: nums = [1], target = 1
Output: 1

Constraints:
    1 <= nums.length <= 20
    0 <= nums[i] <= 1000
    0 <= sum(nums[i]) <= 1000
    -1000 <= target <= 1000

***********************************************************************************************************************************************************************

//This solution is based on "0/1 knapsack problem".
/* Intuition :-     Suppose we assigned '+' sign to some numbers of array and '-' sign to remaining numbers of array. We made 1 subset(S1) for all '+' numbers and  
                    other subset(S2) for all '-' numbers. 
                          S1 - S2  = target       --------(I)
                    We have a variable 'totalSum' to store sum of all elements of given array. We know S1 and S2 are part of the array.
                          S1 + S2  = totalSum     --------(II)
                    from (I) and (II) 
                          S1 = (target + totalSum) / 2     ----------(in below solution it is refered as 'W')
                    Now problem boils down to "count number of subset of given sum 'S1'"
                    
                    According to constraints, zeros are allowed in the array. In addtion, zeros doesn't make in difference, but for each zero there are two possibility
                    whether to include it or not. Hence, we first calculate no of zeros in variable 'countZero' and then multiply ans return by countSubsetOfSum() by
                    pow(2, countZero).
                    One more modification for '0' is needed while filling table of knapsack: if current array element is zero, then copy value from above block. 
                    


class Solution {
    public int findTargetSumWays(int[] nums, int target) {
        int totalSum = 0;
        int countZero = 0;
        
        for(int x : nums){
            if(x==0)    
                countZero++;
            totalSum += x;
        }
        
        if(target > totalSum)
            return 0;
        
        if((target + totalSum)%2 != 0)
            return 0;
        
        int W = (target + totalSum)/2;
        
        return (int)Math.pow(2,countZero) * countSubsetOfSum(nums, W);
    }
    
    static int countSubsetOfSum(int nums[], int W){
        int n = nums.length;
        
        int t[][] = new int[n+1][W+1];
        
        for(int j=0; j<W+1; j++){
            t[0][j] = 0;
        }
        for(int i=0; i<n+1; i++){
            t[i][0] = 1;
        }
        
        for(int i=1; i<n+1; i++){
            for(int j=1; j<W+1; j++){
                if(nums[i-1] == 0)                                    //modification for '0' as explained above
                    t[i][j] = t[i-1][j];
                else if(nums[i-1] > j)
                    t[i][j] = t[i-1][j];
                else
                    t[i][j] = t[i-1][j] + t[i-1][j-nums[i-1]];
            }
        }
        
        return t[n][W];
    }
}
